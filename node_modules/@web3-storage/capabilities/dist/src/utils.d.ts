/**
 * Check URI can be delegated
 *
 * @param {string} [child]
 * @param {string} [parent]
 */
export function canDelegateURI(child?: string | undefined, parent?: string | undefined): true | Failure;
/**
 * Checks that `with` on claimed capability is the same as `with`
 * in delegated capability. Note this will ignore `can` field.
 *
 * @param {Types.ParsedCapability} child
 * @param {Types.ParsedCapability} parent
 */
export function equalWith(child: Types.ParsedCapability, parent: Types.ParsedCapability): true | Failure;
/**
 * @param {unknown} child
 * @param {unknown} parent
 * @param {string} constraint
 */
export function equal(child: unknown, parent: unknown, constraint: string): true | Failure;
/**
 * @param {Types.Failure | true} value
 */
export function fail(value: Types.Failure | true): Types.Failure | undefined;
/**
 *
 * TODO: needs to account for caps derived from different namespaces like 'account/info' can be derived from 'store/add'
 *
 * @param {import('@ucanto/interface').Ability} parent
 * @param {import('@ucanto/interface').Ability} child
 */
export function canDelegateAbility(parent: import('@ucanto/interface').Ability, child: import('@ucanto/interface').Ability): boolean;
export function equalLink<T extends Types.ParsedCapability<"store/add" | "store/remove", Types.URI<"did:">, {
    link?: Types.Link<unknown, number, number, 0 | 1> | undefined;
}>>(claimed: T, delegated: T): Types.Result<true, Types.Failure>;
import { Failure } from "@ucanto/validator/src/lib";
import * as Types from "@ucanto/interface";
//# sourceMappingURL=utils.d.ts.map