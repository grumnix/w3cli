/**
 * Capability can only be delegated (but not invoked) allowing audience to
 * derived any `upload/` prefixed capability for the (memory) space identified
 * by did:key in the `with` field.
 */
export const upload: import("@ucanto/interface").TheCapabilityParser<import("@ucanto/interface").CapabilityMatch<"upload/*", import("@ucanto/interface").URI<"did:">, any>>;
/**
 * Capability allows an agent to add an arbitrary DAG (root) to the upload list
 * of the specified (memory) space (identified by did:key in the `with` field).
 * It is recommended to provide an optional list of shard links that contain
 * fragments of this DAG, as it allows system to optimize block discovery, it is
 * also a way to communicate DAG partiality - this upload contains partial DAG
 * identified by the given `root`.
 *
 * Usually when agent wants to upload a DAG it will encode it as a one or more
 * CAR files (shards) and invoke `store/add` capability for each one. Once all
 * shards are stored it will invoke `upload/add` capability (providing link to
 * a DAG root and all the shards) to add it the upload list.
 *
 * That said `upload/add` could be invoked without invoking `store/add`s e.g.
 * because another (memory) space may already have those CARs.
 *
 * Note: If DAG with the given root is already in the upload list, invocation
 * will simply update `shards` to be a union of existing and new shards.
 */
export const add: import("@ucanto/interface").TheCapabilityParser<import("@ucanto/interface").CapabilityMatch<"upload/add", import("@ucanto/interface").URI<"did:">, Schema.InferStruct<{
    root: typeof Link;
    shards: Schema.Schema<import("@ucanto/interface").Link<unknown, 514, number, 1>[] | undefined, any>;
}>>>;
/**
 * Capability removes an upload (identified by it's root CID) from the upload
 * list. Please note that removing an upload does not delete corresponding shards
 * from the store, however that could be done via `store/remove` invocations.
 */
export const remove: import("@ucanto/interface").TheCapabilityParser<import("@ucanto/interface").CapabilityMatch<"upload/remove", import("@ucanto/interface").URI<"did:">, Schema.InferStruct<{
    root: typeof Link;
}>>>;
/**
 * Capability can be invoked to request a list of uploads in the (memory) space
 * identified by the `with` field.
 */
export const list: import("@ucanto/interface").TheCapabilityParser<import("@ucanto/interface").CapabilityMatch<"upload/list", import("@ucanto/interface").URI<"did:">, Schema.InferStruct<{
    cursor: Schema.Schema<string | undefined, unknown>;
    size: Schema.Schema<(number & import("@ucanto/interface").Phantom<{
        typeof: "integer";
    }>) | undefined, unknown>;
    pre: Schema.Schema<boolean | undefined, unknown>;
}>>>;
export const all: import("@ucanto/interface").CapabilityParser<import("@ucanto/interface").CapabilityMatch<"upload/add", import("@ucanto/interface").URI<"did:">, Schema.InferStruct<{
    root: typeof Link;
    shards: Schema.Schema<import("@ucanto/interface").Link<unknown, 514, number, 1>[] | undefined, any>;
}>> | import("@ucanto/interface").CapabilityMatch<"upload/remove", import("@ucanto/interface").URI<"did:">, Schema.InferStruct<{
    root: typeof Link;
}>> | import("@ucanto/interface").CapabilityMatch<"upload/list", import("@ucanto/interface").URI<"did:">, Schema.InferStruct<{
    cursor: Schema.Schema<string | undefined, unknown>;
    size: Schema.Schema<(number & import("@ucanto/interface").Phantom<{
        typeof: "integer";
    }>) | undefined, unknown>;
    pre: Schema.Schema<boolean | undefined, unknown>;
}>>>;
import { Schema } from "@ucanto/validator/src/lib.js";
import { Link } from "@ucanto/validator/src/schema.js";
export { Link, Schema };
//# sourceMappingURL=upload.d.ts.map