/**
 * @typedef {import('./types').Service} Service
 */
/**
 * Creates a Ucanto connection for the w3access API
 *
 * Usage:
 *
 * ```js
 * import { connection } from '@web3-storage/access/agent'
 * ```
 *
 * @template {Ucanto.DID} T - DID method
 * @param {object} [options]
 * @param {Ucanto.Principal<T>} [options.principal] - w3access API Principal
 * @param {URL} [options.url] - w3access API URL
 * @param {Ucanto.Transport.Channel<Service>} [options.channel] - Ucanto channel to use
 * @param {typeof fetch} [options.fetch] - Fetch implementation to use
 * @returns {Ucanto.ConnectionView<Service>}
 */
export function connection<T extends `did:${string}:${string}`>(options?: {
    principal?: Client.Principal<T> | undefined;
    url?: URL | undefined;
    channel?: Client.Channel<import("./types").Service> | undefined;
    fetch?: typeof fetch | undefined;
} | undefined): Ucanto.ConnectionView<Service>;
/**
 * Given a list of delegations, add to agent data spaces list.
 *
 * @deprecated - trying to remove explicit space tracking from Agent/AgentData
 * in favor of functions that derive the space set from access.delegations
 *
 * @param {Agent} access
 * @param {Ucanto.Delegation<Ucanto.Capabilities>[]} delegations
 */
export function addSpacesFromDelegations(access: Agent, delegations: Ucanto.Delegation<Client.Capabilities>[]): Promise<void>;
export { AgentData };
export * from "./agent-use-cases.js";
/**
 * Agent
 *
 * Usage:
 *
 * ```js
 * import { Agent } from '@web3-storage/access/agent'
 * ```
 */
export class Agent {
    /**
     * Create a new Agent instance, optionally with the passed initialization data.
     *
     * @param {Partial<import('./types').AgentDataModel>} [init]
     * @param {import('./types').AgentOptions & import('./types').AgentDataOptions} [options]
     */
    static create(init?: Partial<import("./types").AgentDataModel> | undefined, options?: (import("./types").AgentOptions & import("./types").AgentDataOptions) | undefined): Promise<Agent>;
    /**
     * Instantiate an Agent from pre-exported agent data.
     *
     * @param {import('./types').AgentDataExport} raw
     * @param {import('./types').AgentOptions & import('./types').AgentDataOptions} [options]
     */
    static from(raw: import('./types').AgentDataExport, options?: (import("./types").AgentOptions & import("./types").AgentDataOptions) | undefined): Agent;
    /**
     * @param {import('./agent-data').AgentData} data - Agent data
     * @param {import('./types').AgentOptions} [options]
     */
    constructor(data: import('./agent-data').AgentData, options?: import("./types").AgentOptions | undefined);
    url: URL;
    connection: Client.ConnectionView<import("./types").Service>;
    get issuer(): Client.Signer<`did:key:${string}`, Client.SigAlg>;
    get meta(): import("./types").AgentMeta;
    get spaces(): Map<`did:${string}:${string}`, import("./types").SpaceMeta>;
    did(): `did:key:${string}`;
    /**
     * Add a proof to the agent store
     *
     * A proof is a delegation with an audience matching agent DID
     *
     * @param {Ucanto.Delegation} delegation
     */
    addProof(delegation: Ucanto.Delegation): Promise<void>;
    /**
     * Clean up any expired delegations.
     */
    removeExpiredDelegations(): Promise<void>;
    /**
     * Get all the proofs matching the capabilities.
     *
     * Proofs are delegations with an audience matching agent DID, or with an
     * audience matching the session DID.
     *
     * Proof of session will also be included in the returned proofs if any
     * proofs matching the passed capabilities require it.
     *
     * @param {import('@ucanto/interface').Capability[]} [caps] - Capabilities to filter by. Empty or undefined caps with return all the proofs.
     */
    proofs(caps?: Client.Capability<Client.Ability, `${string}:${string}`, any>[] | undefined): Client.Delegation<Client.Capabilities>[];
    /**
     * Get delegations created by the agent for others.
     *
     * @param {import('@ucanto/interface').Capability[]} [caps] - Capabilities to filter by. Empty or undefined caps with return all the delegations.
     */
    delegations(caps?: Client.Capability<Client.Ability, `${string}:${string}`, any>[] | undefined): Client.Delegation<Client.Capabilities>[];
    /**
     * Get delegations created by the agent for others and their metadata.
     *
     * @param {import('@ucanto/interface').Capability[]} [caps] - Capabilities to filter by. Empty or undefined caps with return all the delegations.
     */
    delegationsWithMeta(caps?: Client.Capability<Client.Ability, `${string}:${string}`, any>[] | undefined): {
        delegation: Ucanto.Delegation;
        meta: import('./types').DelegationMeta;
    }[];
    /**
     * Creates a space signer and a delegation to the agent
     *
     * @param {string} [name]
     */
    createSpace(name?: string | undefined): Promise<{
        did: `did:key:${string}`;
        meta: import("./types").SpaceMeta;
        proof: Client.Delegation<[{
            can: "*";
            with: Client.URI<"did:">;
            nb: Partial<any>;
        }]>;
    }>;
    /**
     * Import a space from a delegation.
     *
     * @param {Ucanto.Delegation} delegation
     */
    importSpaceFromDelegation(delegation: Ucanto.Delegation): Promise<{
        did: `did:${string}:${string}`;
        meta: import("./types").SpaceMeta;
        proof: Client.Delegation<Client.Capabilities>;
    }>;
    /**
     *
     * @param {string} email
     * @param {object} [opts]
     * @param {AbortSignal} [opts.signal]
     */
    recover(email: string, opts?: {
        signal?: AbortSignal | undefined;
    } | undefined): Promise<Client.Delegation<[{
        can: "*";
        with: `did:${string}` & Client.Phantom<{
            protocol: "did:";
        }> & `${string}:${string}`;
        nb: any;
    }]>[]>;
    /**
     * Sets the current selected space
     *
     * Other methods will default to use the current space if no resource is defined
     *
     * @param {Ucanto.DID<'key'>} space
     */
    setCurrentSpace(space: Ucanto.DID<'key'>): Promise<`did:key:${string}`>;
    /**
     * Get current space DID
     */
    currentSpace(): `did:key:${string}` | undefined;
    /**
     * Get current space DID, proofs and abilities
     */
    currentSpaceWithMeta(): {
        did: `did:key:${string}`;
        proofs: Client.Delegation<Client.Capabilities>[];
        capabilities: any[];
        meta: import("./types").SpaceMeta | undefined;
    } | undefined;
    /**
     * Invokes voucher/redeem for the free tier, wait on the websocket for the voucher/claim and invokes it
     *
     * It also adds a full space delegation to the service in the voucher/claim invocation to allow for recovery
     *
     * @param {string} email
     * @param {object} [opts]
     * @param {AbortSignal} [opts.signal]
     * @param {Ucanto.DID<'key'>} [opts.space] - space to register
     * @param {Ucanto.DID<'web'>} [opts.provider] - provider to register - defaults to this.connection.id
     */
    registerSpace(email: string, opts?: {
        signal?: AbortSignal | undefined;
        space?: `did:key:${string}` | undefined;
        provider?: `did:web:${string}` | undefined;
    } | undefined): Promise<void>;
    /**
     *
     * @param {import('./types').DelegationOptions} options
     */
    delegate(options: import('./types').DelegationOptions): Promise<Client.Delegation<Client.Capabilities>>;
    invokeAndExecute<A extends Client.Ability, R extends Client.URI<`${string}:`>, C extends Client.Caveats>(cap: Client.TheCapabilityParser<Client.CapabilityMatch<A, R, C>>, options: import("./types").InvokeOptions<A, R, Client.TheCapabilityParser<Client.CapabilityMatch<A, R, C>>>): Promise<Client.InferServiceInvocationReturn<Client.InferCapability<Client.ParsedCapability<A, R, C> & Client.Capability<Client.Ability, `${string}:${string}`, unknown>>, import("./types").Service>>;
    /**
     * Execute invocations on the agent's connection
     *
     * @example
     * ```js
     * const i1 = await agent.invoke(Space.info, {})
     * const i2 = await agent.invoke(Space.recover, {
     *   nb: {
     *     identity: 'mailto:hello@web3.storage',
     *   },
     * })
     *
     * const results = await agent.execute2(i1, i2)
     *
     * ```
     * @template {Ucanto.Capability} C
     * @template {Ucanto.Tuple<Ucanto.ServiceInvocation<C, import('./types').Service>>} I
     * @param {I} invocations
     */
    execute<C_1 extends Client.Capability<Client.Ability, `${string}:${string}`, any>, I extends Client.Transport.Tuple<Client.ServiceInvocation<C_1, import("./types").Service>>>(...invocations: I): Client.Await<Client.InferServiceInvocations<I, import("./types").Service>>;
    /**
     * Creates an invocation for the given capability with Agent's proofs, service, issuer and space.
     *
     * @example
     * ```js
     * const recoverInvocation = await agent.invoke(Space.recover, {
     *   nb: {
     *     identity: 'mailto: email@gmail.com',
     *   },
     * })
     *
     * await recoverInvocation.execute(agent.connection)
     * // or
     * await agent.execute(recoverInvocation)
     * ```
     *
     * @template {Ucanto.Ability} A
     * @template {Ucanto.URI} R
     * @template {Ucanto.TheCapabilityParser<Ucanto.CapabilityMatch<A, R, C>>} CAP
     * @template {Ucanto.Caveats} [C={}]
     * @param {CAP} cap
     * @param {import('./types').InvokeOptions<A, R, CAP>} options
     */
    invoke<A_1 extends Client.Ability, R_1 extends Client.URI<`${string}:`>, CAP extends Client.TheCapabilityParser<Client.CapabilityMatch<A_1, R_1, C_2>>, C_2 extends Client.Caveats = {}>(cap: CAP, options: import("./types").InvokeOptions<A_1, R_1, CAP>): Promise<Client.IssuedInvocationView<Client.InferInvokedCapability<CAP>>>;
    /**
     *
     * @param {import('../src/awake/types').Channel} channel
     */
    peer(channel: import('../src/awake/types').Channel): Peer;
    /**
     * Get Space information from Access service
     *
     * @param {Ucanto.URI<"did:">} [space]
     */
    getSpaceInfo(space?: Client.URI<"did:"> | undefined): Promise<import("./types").SpaceInfoResult & {
        error?: undefined;
    }>;
    #private;
}
export type Service = import('./types').Service;
import * as Ucanto from "@ucanto/interface";
import * as Client from "@ucanto/client/src/lib.js";
import { AgentData } from "./agent-data.js";
import { DID } from "@ucanto/core/lib.js";
import { Peer } from "./awake/peer.js";
//# sourceMappingURL=agent.d.ts.map