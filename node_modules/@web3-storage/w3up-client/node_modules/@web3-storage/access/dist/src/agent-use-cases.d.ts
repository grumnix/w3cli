/**
 * Request access by a session allowing this agent to issue UCANs
 * signed by the account.
 *
 * @param {AccessAgent} access
 * @param {Ucanto.Principal<Ucanto.DID<'mailto'>>} account
 * @param {Iterable<{ can: Ucanto.Ability }>} capabilities
 */
export function requestAccess(access: AccessAgent, account: Ucanto.Principal<Ucanto.DID<'mailto'>>, capabilities: Iterable<{
    can: Ucanto.Ability;
}>): Promise<void>;
/**
 * claim delegations delegated to an audience
 *
 * @param {AccessAgent} access
 * @param {Ucanto.DID} [audienceOfClaimedDelegations] - audience of claimed delegations. defaults to access.connection.id.did()
 * @param {object} opts
 * @param {boolean} [opts.addProofs] - whether to addProof to access agent
 * @returns
 */
export function claimAccess(access: AccessAgent, audienceOfClaimedDelegations?: `did:${string}:${string}` | undefined, { addProofs }?: {
    addProofs?: boolean | undefined;
}): Promise<Ucanto.Delegation<Ucanto.Capabilities>[]>;
/**
 * @param {object} opts
 * @param {AccessAgent} opts.access
 * @param {Ucanto.DID<'key'>} opts.space
 * @param {Ucanto.Principal<Ucanto.DID<'mailto'>>} opts.account
 * @param {Ucanto.DID<'web'>} opts.provider - e.g. 'did:web:staging.web3.storage'
 */
export function addProvider({ access, space, account, provider }: {
    access: AccessAgent;
    space: Ucanto.DID<'key'>;
    account: Ucanto.Principal<Ucanto.DID<'mailto'>>;
    provider: Ucanto.DID<'web'>;
}): Promise<void>;
export function delegationsIncludeSessionProof(delegations: Ucanto.Delegation<Ucanto.Capabilities>[]): boolean;
/**
 * @param {DelegationsChecker} delegationsMatch
 * @param {AccessAgent} access
 * @param {Ucanto.DID} delegee
 * @param {object} [opts]
 * @param {number} [opts.interval]
 * @param {AbortSignal} [opts.signal]
 * @returns {Promise<Iterable<Ucanto.Delegation>>}
 */
export function pollAccessClaimUntil(delegationsMatch: DelegationsChecker, access: AccessAgent, delegee: Ucanto.DID, opts?: {
    interval?: number | undefined;
    signal?: AbortSignal | undefined;
} | undefined): Promise<Iterable<Ucanto.Delegation>>;
/**
 * @param {AccessAgent} access
 * @param {object} [opts]
 * @param {AbortSignal} [opts.signal]
 * @deprecated - use waitForAuthorizationOnSocket
 */
export function waitForDelegationOnSocket(access: AccessAgent, opts?: {
    signal?: AbortSignal | undefined;
} | undefined): Promise<Ucanto.Delegation<Ucanto.Capabilities>>;
export function waitForAuthorizationOnSocket(accessAgent: AccessAgent, opts: {
    signal?: AbortSignal | undefined;
}): Promise<Iterable<Ucanto.Delegation>>;
export function waitForAuthorizationByPolling(accessAgent: AccessAgent, opts: AuthorizationWaiterOpts<{
    interval?: number | undefined;
}>): Promise<Iterable<Ucanto.Delegation>>;
/**
 * Request authorization of a session allowing this agent to issue UCANs
 * signed by the passed email address.
 *
 * @param {AccessAgent} access
 * @param {`${string}@${string}`} email
 * @param {object} [opts]
 * @param {AbortSignal} [opts.signal]
 * @param {boolean} [opts.dontAddProofs] - whether to skip adding proofs to the agent
 * @param {Iterable<{ can: Ucanto.Ability }>} [opts.capabilities]
 * @param {AuthorizationWaiter} [opts.expectAuthorization] - function that will resolve once account has confirmed the authorization request
 */
export function authorizeAndWait(access: AccessAgent, email: `${string}@${string}`, opts?: {
    signal?: AbortSignal | undefined;
    dontAddProofs?: boolean | undefined;
    capabilities?: Iterable<{
        can: Ucanto.Ability;
    }> | undefined;
    expectAuthorization?: AuthorizationWaiter<{}> | undefined;
} | undefined): Promise<void>;
/**
 * Request authorization of a session allowing this agent to issue UCANs
 * signed by the passed email address.
 *
 * @param {AccessAgent} accessAgent
 * @param {`${string}@${string}`} email
 * @param {object} [opts]
 * @param {AbortSignal} [opts.signal]
 * @param {Iterable<{ can: Ucanto.Ability }>} [opts.capabilities]
 * @param {boolean} [opts.addProofs]
 * @param {AuthorizationWaiter} [opts.expectAuthorization] - function that will resolve once account has confirmed the authorization request
 */
export function authorizeWaitAndClaim(accessAgent: AccessAgent, email: `${string}@${string}`, opts?: {
    signal?: AbortSignal | undefined;
    capabilities?: Iterable<{
        can: Ucanto.Ability;
    }> | undefined;
    addProofs?: boolean | undefined;
    expectAuthorization?: AuthorizationWaiter<{}> | undefined;
} | undefined): Promise<void>;
/**
 * Request authorization of a session allowing this agent to issue UCANs
 * signed by the passed email address.
 *
 * @param {AccessAgent} access
 * @param {`${string}@${string}`} email
 * @param {object} [opts]
 * @param {AbortSignal} [opts.signal]
 * @param {Iterable<{ can: Ucanto.Ability }>} [opts.capabilities]
 * @deprecated use authorizeWaitAndClaim directly going forward, passing it the expectAuthorization: waitForAuthorizationOnSocket to replicate this function's behavior
 */
export function authorizeWithSocket(access: AccessAgent, email: `${string}@${string}`, opts?: {
    signal?: AbortSignal | undefined;
    capabilities?: Iterable<{
        can: Ucanto.Ability;
    }> | undefined;
} | undefined): Promise<void>;
/**
 * Invokes voucher/redeem for the free tier, wait on the websocket for the voucher/claim and invokes it
 *
 * It also adds a full space delegation to the service in the voucher/claim invocation to allow for recovery
 *
 * @param {AccessAgent} access
 * @param {AgentData} agentData
 * @param {string} email
 * @param {object} [opts]
 * @param {AbortSignal} [opts.signal]
 * @param {Ucanto.DID<'key'>} [opts.space]
 * @param {Ucanto.DID<'web'>} [opts.provider] - provider to register - defaults to this.connection.id
 */
export function addProviderAndDelegateToAccount(access: AccessAgent, agentData: AgentData, email: string, opts?: {
    signal?: AbortSignal | undefined;
    space?: `did:key:${string}` | undefined;
    provider?: `did:web:${string}` | undefined;
} | undefined): Promise<void>;
export type DelegationsChecker = (delegations: Ucanto.Delegation<Ucanto.Capabilities>[]) => boolean;
export type AuthorizationWaiterOpts<T = {}> = {
    signal?: AbortSignal;
} & T;
export type AuthorizationWaiter<U = {}> = (accessAgent: AccessAgent, opts: AuthorizationWaiterOpts<U>) => Promise<Iterable<Ucanto.Delegation>>;
import { Agent as AccessAgent } from "./agent.js";
import * as Ucanto from "@ucanto/interface";
import { AgentData } from "./agent-data.js";
//# sourceMappingURL=agent-use-cases.d.ts.map