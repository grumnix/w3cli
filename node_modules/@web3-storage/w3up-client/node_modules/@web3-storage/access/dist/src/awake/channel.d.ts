/**
 * @template [T=unknown]
 * @typedef {(event: T) => void} Handler
 */
/**
 * @template [T=unknown]
 * @typedef {Array<Handler<T>> } EventHandlerList
 */
/**
 * @template {Record<import('./types').MessageType, unknown>} [Events=Record<import('./types').MessageType, unknown>]
 * @typedef {Map<keyof Events, EventHandlerList<Events[keyof Events]>>} EventHandlerMap
 */
/**
 * @typedef {import('./types').Channel} ChannelType
 * @implements {ChannelType}
 */
export class Channel implements ChannelType {
    /**
     * @param {string | URL} host
     * @param {string} topic
     * @param {import('../crypto/types').KeyExchangeKeypair} keypair
     */
    constructor(host: string | URL, topic: string, keypair: import('../crypto/types').KeyExchangeKeypair);
    url: URL;
    ws: WS | undefined;
    keypair: import("../crypto/types").KeyExchangeKeypair;
    onMessage: any;
    attemps: number;
    /**
     * @type {string | number | NodeJS.Timeout | undefined}
     */
    timeout: string | number | NodeJS.Timeout | undefined;
    forceClose: boolean;
    open(): Promise<Channel>;
    connect(): WS | undefined;
    /**
     * @param {number} [code]
     * @param {string | Buffer } [reason]
     */
    close(code?: number | undefined, reason?: string | Buffer | undefined): Promise<Channel>;
    /**
     * @param {any} data
     */
    send(data: any): void;
    /**
     * @param {import('./types').MessageType} type
     * @param { Handler } fn
     * @param {boolean} [once]
     */
    subscribe(type: import('./types').MessageType, fn: Handler<unknown>, once?: boolean | undefined): () => void;
    /**
     * @param {import('./types').MessageType} type
     * @param { Handler } fn
     */
    unsubscribe(type: import('./types').MessageType, fn: Handler<unknown>): void;
    /**
     * @private
     * @param {import('./types').AwakeMessage} data
     */
    private publish;
    awaitInit(): Promise<import("./types").AwakeInit>;
    awaitRes(): Promise<import("./types").AwakeRes>;
    awaitMsg(did: UCAN.Principal<`did:${string}:${string}`>): Promise<import("./types").AwakeMsgDecrypted>;
    sendInit(caps: UCAN.Capabilities): Promise<void>;
    sendRes(aud: UCAN.Principal<`did:${string}:${string}`>, msg: UCAN.View<UCAN.Capabilities>): Promise<void>;
    sendMsg(did: UCAN.Principal<`did:${string}:${string}`>, msg: unknown): Promise<void>;
    sendFin(did: UCAN.Principal<`did:${string}:${string}`>): Promise<void>;
    #private;
}
export type Handler<T = unknown> = (event: T) => void;
export type EventHandlerList<T = unknown> = Array<Handler<T>>;
export type EventHandlerMap<Events extends Record<"awake/init" | "awake/res" | "awake/msg", unknown> = Record<"awake/init" | "awake/res" | "awake/msg", unknown>> = Map<keyof Events, EventHandlerList<Events[keyof Events]>>;
export type ChannelType = import('./types').Channel;
import WS from "isomorphic-ws";
import * as UCAN from "@ipld/dag-ucan/.";
//# sourceMappingURL=channel.d.ts.map