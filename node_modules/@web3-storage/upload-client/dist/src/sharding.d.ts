/**
 * Shard a set of blocks into a set of CAR files. By default the last block
 * received is assumed to be the DAG root and becomes the CAR root CID for the
 * last CAR output. Set the `rootCID` option to override.
 *
 * @extends {TransformStream<import('@ipld/unixfs').Block, import('./types').CARFile>}
 */
export class ShardingStream extends TransformStream<import("@ipld/unixfs/src/unixfs.js").Block<any, number, number, import("multiformats").Version>, import("./types").CARFile> {
    /**
     * @param {import('./types').ShardingOptions} [options]
     */
    constructor(options?: import("./types").ShardingOptions | undefined);
}
/**
 * Upload multiple DAG shards (encoded as CAR files) to the service.
 *
 * Note: an "upload" must be registered in order to link multiple shards
 * together as a complete upload.
 *
 * The writeable side of this transform stream accepts CAR files and the
 * readable side yields `CARMetadata`.
 *
 * @extends {TransformStream<import('./types').CARFile, import('./types').CARMetadata>}
 */
export class ShardStoringStream extends TransformStream<import("./types").CARFile, import("./types").CARMetadata> {
    /**
     * @param {import('./types').InvocationConfig} conf Configuration
     * for the UCAN invocation. An object with `issuer`, `with` and `proofs`.
     *
     * The `issuer` is the signing authority that is issuing the UCAN
     * invocation(s). It is typically the user _agent_.
     *
     * The `with` is the resource the invocation applies to. It is typically the
     * DID of a space.
     *
     * The `proofs` are a set of capability delegations that prove the issuer
     * has the capability to perform the action.
     *
     * The issuer needs the `store/add` delegated capability.
     * @param {import('./types').ShardStoringOptions} [options]
     */
    constructor(conf: import('./types').InvocationConfig, options?: import("./types").ShardStoringOptions | undefined);
}
//# sourceMappingURL=sharding.d.ts.map