export const code: 514;
export function createWriter(): Writer;
export function encode<T extends Partial<Model>>({ roots, blocks }: T): API.ByteView<T>;
export function decode(bytes: API.ByteView<Partial<Model>>): Model;
export function link<T extends Partial<Model>>(bytes: API.ByteView<T>, { hasher }?: {
    hasher?: API.MultihashHasher;
}): Promise<API.Link<T, 514, number, 1>>;
export function write<T extends Partial<Model>>(data: T, options?: {
    hasher?: API.MultihashHasher<number> | undefined;
} | undefined): Promise<API.Transport.Block<T, 514, number, 1>>;
export type Block = API.Block<unknown, number, number, 0 | 1>;
export type Model = {
    roots: Block[];
    blocks: Map<string, Block>;
};
/**
 * @typedef {API.Block<unknown, number, number, 0|1>} Block
 * @typedef {{
 * roots: Block[]
 * blocks: Map<string, Block>
 * }} Model
 */
declare class Writer {
    /**
     * @param {Block[]} blocks
     * @param {number} byteLength
     */
    constructor(blocks?: Block[], byteLength?: number);
    written: Set<any>;
    blocks: Block[];
    byteLength: number;
    /**
     * @param {Block[]} blocks
     */
    write(...blocks: Block[]): Writer;
    /**
     * @param {Block[]} rootBlocks
     */
    flush(...rootBlocks: Block[]): Uint8Array;
}
import * as API from "@ucanto/interface";
export {};
//# sourceMappingURL=codec.d.ts.map