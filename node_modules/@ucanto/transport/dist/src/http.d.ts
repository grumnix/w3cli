export function open<T>({ url, method, fetch }: {
    url: URL;
    fetch?: ((url: string, init: API.HTTPRequest<API.Transport.Tuple<API.ServiceInvocation<API.Capability<API.Ability, `${string}:${string}`, unknown>, {
        [x: string]: {
            [x: string]: API.ServiceMethod<API.Capability<API.Ability, `${string}:${string}`, unknown>, any, any>;
        };
    } | {
        "*": API.ServiceMethod<API.Capability<API.Ability, `${string}:${string}`, unknown>, any, any>;
    }>>>) => API.Await<FetchResponse>) | undefined;
    method?: string | undefined;
}): API.Channel<T>;
export type FetchResponse = {
    ok: boolean;
    arrayBuffer(): API.Await<ArrayBuffer>;
    headers: {
        entries?: () => Iterable<[string, string]>;
    } | Headers;
    status?: number;
    statusText?: string;
    url?: string;
};
export type Fetcher = (url: string, init: API.HTTPRequest<API.Transport.Tuple<API.ServiceInvocation<API.Capability<API.Ability, `${string}:${string}`, unknown>, {
    [x: string]: {
        [x: string]: API.ServiceMethod<API.Capability<API.Ability, `${string}:${string}`, unknown>, any, any>;
    };
} | {
    "*": API.ServiceMethod<API.Capability<API.Ability, `${string}:${string}`, unknown>, any, any>;
}>>>) => API.Await<FetchResponse>;
export type Options = {
    status?: number;
    statusText?: string;
    url?: string;
};
import * as API from "@ucanto/interface";
declare class Channel {
    /**
     * @param {object} options
     * @param {URL} options.url
     * @param {Fetcher} options.fetch
     * @param {string} [options.method]
     */
    constructor({ url, fetch, method }: {
        url: URL;
        fetch: Fetcher;
        method?: string | undefined;
    });
    fetch: Fetcher;
    method: string | undefined;
    url: URL;
    /**
     * @param {API.HTTPRequest} request
     * @returns {Promise<API.HTTPResponse>}
     */
    request({ headers, body }: API.HTTPRequest): Promise<API.HTTPResponse>;
}
export {};
//# sourceMappingURL=http.d.ts.map