export function isLink(value: API.Proof): value is UCAN.Link<UCAN.Capabilities, UCAN.MulticodecCode<number, string>, UCAN.SigAlg>;
export function isDelegation(proof: API.Proof): proof is API.Delegation<UCAN.Capabilities>;
export function allows<T extends [API.Delegation<UCAN.Capabilities>, ...API.Delegation<UCAN.Capabilities>[]]>(...delegations: T): API.InferAllowedFromDelegations<T>;
/**
 * Represents UCAN chain view over the set of DAG UCAN nodes. You can think of
 * this as UCAN interface of the CAR.
 *
 * @template {API.Capabilities} C
 * @implements {API.Delegation<C>}
 * @extends {DelegationView<C>}
 */
export class Delegation<C extends UCAN.Capabilities> implements API.Delegation<C> {
    /**
     * @param {API.UCANBlock<C>} root
     * @param {Map<string, API.Block>} [blocks]
     */
    constructor(root: API.UCANBlock<C>, blocks?: Map<string, API.Transport.Block<any, number, number, 1>> | undefined);
    root: UCAN.Block<C, UCAN.MulticodecCode<number, string>, UCAN.SigAlg>;
    blocks: Map<string, API.Transport.Block<any, number, number, 1>>;
    get version(): `${number}.${number}.${number}`;
    get signature(): UCAN.Signature<unknown, UCAN.SigAlg>;
    get cid(): UCAN.IPLDLink<UCAN.UCAN<C>, UCAN.MulticodecCode<number, string>, UCAN.SigAlg, 1>;
    get asCID(): UCAN.IPLDLink<UCAN.UCAN<C>, UCAN.MulticodecCode<number, string>, UCAN.SigAlg, 1>;
    get bytes(): UCAN.ByteView<UCAN.UCAN<C>>;
    get data(): UCAN.View<C>;
    export(): IterableIterator<API.Transport.Block<any, number, number, 1>>;
    /**
     * @type {API.Proof[]}
     */
    get proofs(): API.Proof<UCAN.Capabilities>[];
    /**
     * @type {API.Principal}
     */
    get issuer(): UCAN.Principal<`did:${string}:${string}`>;
    /**
     * @type {API.Principal}
     */
    get audience(): UCAN.Principal<`did:${string}:${string}`>;
    /**
     * @returns {C}
     */
    get capabilities(): C;
    /**
     * @returns {number}
     */
    get expiration(): number;
    /**
     * @returns {undefined|number}
     */
    get notBefore(): number | undefined;
    /**
     * @returns {undefined|string}
     */
    get nonce(): string | undefined;
    /**
     * @returns {API.Fact[]}
     */
    get facts(): UCAN.Fact[];
    /**
     * Iterate over the proofs
     *
     * @returns {IterableIterator<API.Delegation>}
     */
    iterate(): IterableIterator<API.Delegation>;
    delegate(): Delegation<C>;
    /**
     * @returns {API.DelegationJSON<this>}
     */
    toJSON(): API.DelegationJSON<Delegation<C>>;
}
export function delegate<C extends UCAN.Capabilities>({ issuer, audience, proofs, ...input }: API.DelegationOptions<C>, options?: API.EncodeOptions | undefined): Promise<API.Delegation<C>>;
export function exportDAG<C extends UCAN.Capabilities>(root: UCAN.Block<C, UCAN.MulticodecCode<number, string>, UCAN.SigAlg>, blocks: Map<string, API.Block>): IterableIterator<API.Block>;
export function importDAG<C extends UCAN.Capabilities>(dag: Iterable<API.Block>): API.Delegation<C>;
export function create<C extends UCAN.Capabilities>({ root, blocks }: {
    root: UCAN.Block<C, UCAN.MulticodecCode<number, string>, UCAN.SigAlg>;
    blocks?: Map<string, API.Transport.Block<unknown, number, number, 1>> | undefined;
}): API.Delegation<C>;
export { Delegation as View };
import * as API from "@ucanto/interface";
import * as UCAN from "@ipld/dag-ucan/.";
//# sourceMappingURL=delegation.d.ts.map