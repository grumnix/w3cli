export function connect<T extends Record<string, any>>(options: API.ConnectionOptions<T>): API.ConnectionView<T>;
export function execute<C extends API.Capability<API.Ability, `${string}:${string}`, any>, T extends Record<string, any>, I extends API.Transport.Tuple<API.ServiceInvocation<C, T>>>(invocations: I, connection: API.Connection<T>): Promise<API.InferServiceInvocations<I, T>>;
import * as API from "@ucanto/interface";
/**
 * @template {Record<string, any>} T
 * @implements {API.ConnectionView<T>}
 */
declare class Connection<T extends Record<string, any>> implements API.ConnectionView<T> {
    /**
     * @param {API.ConnectionOptions<T>} options
     */
    constructor(options: API.ConnectionOptions<T>);
    id: API.Principal<`did:${string}:${string}`>;
    options: API.ConnectionOptions<T>;
    encoder: API.RequestEncoder;
    decoder: API.ResponseDecoder;
    channel: API.Channel<T>;
    hasher: API.MultihashHasher<number>;
    /**
     * @template {API.Capability} C
     * @template {API.Tuple<API.ServiceInvocation<C, T>>} I
     * @param {I} invocations
     */
    execute<C extends API.Capability<API.Ability, `${string}:${string}`, any>, I extends API.Transport.Tuple<API.ServiceInvocation<C, T>>>(...invocations: I): Promise<API.InferServiceInvocations<I, T>>;
}
export {};
//# sourceMappingURL=connection.d.ts.map