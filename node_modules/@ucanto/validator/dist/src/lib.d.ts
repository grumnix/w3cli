export { capability } from "./capability.js";
export * from "./schema.js";
export function access<A extends API.Ability, R extends API.URI<`${string}:`>, URI extends R, C extends API.Caveats>(invocation: API.Invocation<API.Capability<A, URI, C>>, { capability, ...config }: API.ValidationOptions<API.ParsedCapability<A, R, C>>): Promise<API.Result<Authorization<API.ParsedCapability<A, R, C>>, API.Unauthorized>>;
export function claim<A extends API.Ability, R extends API.URI<`${string}:`>, C extends API.Caveats>(capability: API.CapabilityParser<API.Match<API.ParsedCapability<A, R, C>, API.UnknownMatch>>, proofs: API.Proof[], { authority, principal, resolveDIDKey, canIssue, resolve, }: API.ClaimOptions): Promise<API.Result<Authorization<API.ParsedCapability<A, R, C>>, API.Unauthorized>>;
export function authorize<Match extends API.Match<any, API.UnknownMatch>>(match: Match, config: Required<API.ClaimOptions>): Promise<API.Result<Authorization<API.ParsedCapability>, API.InvalidClaim>>;
import { Failure } from "./error.js";
import { UnavailableProof } from "./error.js";
import { MalformedCapability } from "./error.js";
import { DIDKeyResolutionError } from "./error.js";
import * as Schema from "./schema.js";
import * as API from "@ucanto/interface";
/**
 * @template {API.ParsedCapability} C
 */
declare class Authorization<C extends API.ParsedCapability<API.Ability, API.URI<`${string}:`>, any>> {
    /**
     * @param {API.Match<C>} match
     * @param {Authorization<API.ParsedCapability>[]} proofs
     */
    constructor(match: API.Match<C>, proofs: Authorization<API.ParsedCapability>[]);
    match: API.Match<C, API.UnknownMatch>;
    proofs: Authorization<API.ParsedCapability<API.Ability, API.URI<`${string}:`>, any>>[];
    get capability(): C;
    get delegation(): API.Delegation<API.Capabilities>;
    get issuer(): API.Principal<`did:${string}:${string}`>;
    get audience(): API.Principal<`did:${string}:${string}`>;
}
/**
 * @implements {API.Unauthorized}
 */
declare class Unauthorized extends Failure implements API.Unauthorized {
    /**
     * @param {{
     * capability: API.CapabilityParser
     * delegationErrors: API.DelegationError[]
     * unknownCapabilities: API.Capability[]
     * invalidProofs: API.InvalidProof[]
     * failedProofs: API.InvalidClaim[]
     * }} cause
     */
    constructor({ capability, delegationErrors, unknownCapabilities, invalidProofs, failedProofs, }: {
        capability: API.CapabilityParser;
        delegationErrors: API.DelegationError[];
        unknownCapabilities: API.Capability[];
        invalidProofs: API.InvalidProof[];
        failedProofs: API.InvalidClaim[];
    });
    /** @type {"Unauthorized"} */
    name: "Unauthorized";
    capability: API.CapabilityParser<API.Match<unknown, API.UnknownMatch>>;
    delegationErrors: API.DelegationError[];
    unknownCapabilities: API.Capability<API.Ability, `${string}:${string}`, any>[];
    invalidProofs: API.InvalidProof[];
    failedProofs: API.InvalidClaim[];
    toJSON(): {
        error: true;
        name: "Unauthorized";
        message: string;
        stack: string | undefined;
    };
}
/**
 * @implements {API.InvalidClaim}
 */
declare class InvalidClaim extends Failure implements API.InvalidClaim {
    /**
     * @param {{
     * match: API.Match
     * delegationErrors: API.DelegationError[]
     * unknownCapabilities: API.Capability[]
     * invalidProofs: ProofError[]
     * failedProofs: API.InvalidClaim[]
     * }} info
     */
    constructor(info: {
        match: API.Match;
        delegationErrors: API.DelegationError[];
        unknownCapabilities: API.Capability[];
        invalidProofs: ProofError[];
        failedProofs: API.InvalidClaim[];
    });
    info: {
        match: API.Match;
        delegationErrors: API.DelegationError[];
        unknownCapabilities: API.Capability[];
        invalidProofs: ProofError[];
        failedProofs: API.InvalidClaim[];
    };
    /** @type {"InvalidClaim"} */
    name: "InvalidClaim";
    get issuer(): API.Principal<`did:${string}:${string}`>;
    get delegation(): API.Delegation<API.Capabilities>;
}
import { capability } from "./capability.js";
import { DelegationError } from "./error.js";
declare class ProofError extends Failure {
    /**
     * @param {API.UCANLink} proof
     * @param {API.Failure} cause
     */
    constructor(proof: API.UCANLink, cause: API.Failure);
    proof: API.UCANLink<API.Capabilities, API.MulticodecCode<number, string>, API.SigAlg>;
    cause: API.Failure;
}
export { Failure, UnavailableProof, MalformedCapability, DIDKeyResolutionError as DIDResolutionError, Schema };
//# sourceMappingURL=lib.d.ts.map